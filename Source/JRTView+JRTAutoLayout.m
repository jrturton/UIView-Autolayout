//
//  JRTView+JRTAutoLayout.m
//
//  Created by Richard Turton on 18/10/2012.
//

#import "JRTView+JRTAutoLayout.h"

#import <Availability.h>

@interface JRTView (JRTAutoLayoutPrivate)

/**
 *  Searches the view hierarchy to find the common superview between the receiver and the `peerView`.
 *
 *  @param peerView The other view in the view hierarchy where the superview should be located.
 *
 *  @return The common superview between the receiver and the `peerView` or nil if the views are not contained in the same view hierarchy.
 */
- (JRTView*)commonSuperviewWithView:(JRTView*)peerView;

/**
 *  Applys an attribute to the receiver with a specific constant and relation.
 *
 *  @param attribute The attribute of the receiver that you want to pin.
 *  @param constant  The constant that you want to apply to the constraint.
 *  @param relation  The relation that you wish to apply to the constraint.
 *
 *  @return The `NSLayoutConstraint` generated by this method.
 */
- (NSLayoutConstraint *)applyAttribute:(NSLayoutAttribute)attribute withConstant:(CGFloat)constant relation:(NSLayoutRelation)relation;

@end

@implementation JRTView (JRTAutoLayout)

#pragma mark - Initializing a View Object

+(instancetype)autoLayoutView
{
    JRTView *viewToReturn = [self new];
    viewToReturn.translatesAutoresizingMaskIntoConstraints = NO;
    return viewToReturn;
}

#pragma mark - Pinning to the Superview

#if TARGET_OS_IPHONE

-(NSArray*)pinToSuperviewEdges:(JRTViewPinEdges)edges inset:(CGFloat)inset
{
    return [self pinToSuperviewEdges:edges inset:inset usingLayoutGuidesFrom:nil];
}

-(NSArray*)pinToSuperviewEdges:(JRTViewPinEdges)edges inset:(CGFloat)inset usingLayoutGuidesFrom:(UIViewController *)viewController
{
    JRTView *superview = self.superview;
    NSAssert(superview,@"Can't pin to a superview if no superview exists");

    id topItem = nil;
    id bottomItem = nil;

#ifdef __IPHONE_7_0
    if (viewController && [viewController respondsToSelector:@selector(topLayoutGuide)])
    {
        topItem = viewController.topLayoutGuide;
        bottomItem = viewController.bottomLayoutGuide;
    }
#endif

    NSMutableArray *constraints = [NSMutableArray new];

    if (edges & JRTViewPinTopEdge)
    {
        id item = topItem ? topItem : superview;
        NSLayoutAttribute attribute = topItem ? NSLayoutAttributeBottom : NSLayoutAttributeTop;
        [constraints addObject:[self pinAttribute:NSLayoutAttributeTop toAttribute:attribute ofItem:item withConstant:inset]];
    }
    if (edges & JRTViewPinLeftEdge)
    {
        [constraints addObject:[self pinAttribute:NSLayoutAttributeLeft toAttribute:NSLayoutAttributeLeft ofItem:superview withConstant:inset]];
    }
    if (edges & JRTViewPinRightEdge)
    {
        [constraints addObject:[self pinAttribute:NSLayoutAttributeRight toAttribute:NSLayoutAttributeRight ofItem:superview withConstant:-inset]];
    }
    if (edges & JRTViewPinBottomEdge)
    {
        id item = bottomItem ? bottomItem : superview;
        NSLayoutAttribute attribute = bottomItem ? NSLayoutAttributeTop : NSLayoutAttributeBottom;
        [constraints addObject:[self pinAttribute:NSLayoutAttributeBottom toAttribute:attribute ofItem:item withConstant:-inset]];
    }
    return [constraints copy];
}

#else

-(NSArray*)pinToSuperviewEdges:(JRTViewPinEdges)edges inset:(CGFloat)inset
{
    JRTView *superview = self.superview;
    NSAssert(superview,@"Can't pin to a superview if no superview exists");
    
    id topItem = nil;
    id bottomItem = nil;
    
    NSMutableArray *constraints = [NSMutableArray new];
    
    if (edges & JRTViewPinTopEdge)
    {
        id item = topItem ? topItem : superview;
        NSLayoutAttribute attribute = topItem ? NSLayoutAttributeBottom : NSLayoutAttributeTop;
        [constraints addObject:[self pinAttribute:NSLayoutAttributeTop toAttribute:attribute ofItem:item withConstant:inset]];
    }
    if (edges & JRTViewPinLeftEdge)
    {
        [constraints addObject:[self pinAttribute:NSLayoutAttributeLeft toAttribute:NSLayoutAttributeLeft ofItem:superview withConstant:inset]];
    }
    if (edges & JRTViewPinRightEdge)
    {
        [constraints addObject:[self pinAttribute:NSLayoutAttributeRight toAttribute:NSLayoutAttributeRight ofItem:superview withConstant:-inset]];
    }
    if (edges & JRTViewPinBottomEdge)
    {
        id item = bottomItem ? bottomItem : superview;
        NSLayoutAttribute attribute = bottomItem ? NSLayoutAttributeTop : NSLayoutAttributeBottom;
        [constraints addObject:[self pinAttribute:NSLayoutAttributeBottom toAttribute:attribute ofItem:item withConstant:-inset]];
    }
    return [constraints copy];
}

#endif


-(NSArray*)pinToSuperviewEdgesWithInset:(JRTEdgeInsets)insets
{
    NSMutableArray *constraints = [NSMutableArray new];

    [constraints addObjectsFromArray:[self pinToSuperviewEdges:JRTViewPinTopEdge inset:insets.top]];
    [constraints addObjectsFromArray:[self pinToSuperviewEdges:JRTViewPinLeftEdge inset:insets.left]];
    [constraints addObjectsFromArray:[self pinToSuperviewEdges:JRTViewPinBottomEdge inset:insets.bottom]];
    [constraints addObjectsFromArray:[self pinToSuperviewEdges:JRTViewPinRightEdge inset:insets.right]];

    return [constraints copy];
}

#pragma mark - Centering Views

-(NSArray *)centerInView:(JRTView*)view
{
    NSMutableArray *constraints = [NSMutableArray new];

    [constraints addObject:[self centerInView:view onAxis:NSLayoutAttributeCenterX]];
    [constraints addObject:[self centerInView:view onAxis:NSLayoutAttributeCenterY]];

    return [constraints copy];
}

-(NSArray *)centerInContainer
{
    return [self centerInView:self.superview];
}

-(NSLayoutConstraint *)centerInContainerOnAxis:(NSLayoutAttribute)axis
{
    return [self centerInView:self.superview onAxis:axis];
}

-(NSLayoutConstraint *)centerInView:(JRTView *)view onAxis:(NSLayoutAttribute)axis
{
    NSParameterAssert(axis == NSLayoutAttributeCenterX || axis == NSLayoutAttributeCenterY);
    return [self pinAttribute:axis toSameAttributeOfItem:view];
}

#pragma mark - Constraining to a fixed size

-(NSArray *)constrainToSize:(CGSize)size
{
    NSMutableArray *constraints = [NSMutableArray new];

    if (size.width)
        [constraints addObject:[self constrainToWidth:size.width]];
    if (size.height)
        [constraints addObject:[self constrainToHeight:size.height]];

    return [constraints copy];
}

-(NSLayoutConstraint *)constrainToWidth:(CGFloat)width
{
    return [self applyAttribute:NSLayoutAttributeWidth withConstant:width relation:NSLayoutRelationEqual];
}

-(NSLayoutConstraint *)constrainToHeight:(CGFloat)height
{
    return [self applyAttribute:NSLayoutAttributeHeight withConstant:height relation:NSLayoutRelationEqual];
}

-(NSArray *)constrainToMinimumSize:(CGSize)minimum maximumSize:(CGSize)maximum
{
    NSAssert(minimum.width <= maximum.width, @"maximum width should be strictly wider than or equal to minimum width");
    NSAssert(minimum.height <= maximum.height, @"maximum height should be strictly higher than or equal to minimum height");
    NSArray *minimumConstraints = [self constrainToMinimumSize:minimum];
    NSArray *maximumConstraints = [self constrainToMaximumSize:maximum];
    return [minimumConstraints arrayByAddingObjectsFromArray:maximumConstraints];
}

-(NSArray *)constrainToMinimumSize:(CGSize)minimum
{
    NSMutableArray *constraints = [NSMutableArray array];
    if (minimum.width)
        [constraints addObject:[self applyAttribute:NSLayoutAttributeWidth withConstant:minimum.width relation:NSLayoutRelationGreaterThanOrEqual]];
    if (minimum.height)
        [constraints addObject:[self applyAttribute:NSLayoutAttributeHeight withConstant:minimum.height relation:NSLayoutRelationGreaterThanOrEqual]];
    return [constraints copy];
}

-(NSArray *)constrainToMaximumSize:(CGSize)maximum
{
    NSMutableArray *constraints = [NSMutableArray array];
    if (maximum.width)
        [constraints addObject:[self applyAttribute:NSLayoutAttributeWidth withConstant:maximum.width relation:NSLayoutRelationLessThanOrEqual]];
    if (maximum.height)
        [constraints addObject:[self applyAttribute:NSLayoutAttributeHeight withConstant:maximum.height relation:NSLayoutRelationLessThanOrEqual]];
    return [constraints copy];
}

#pragma mark - Pinning to other items

- (NSLayoutConstraint *)pinAttribute:(NSLayoutAttribute)attribute toAttribute:(NSLayoutAttribute)toAttribute ofItem:(id)peerItem withConstant:(CGFloat)constant
{
    return [self pinAttribute:attribute toAttribute:toAttribute ofItem:peerItem withConstant:constant relation:NSLayoutRelationEqual];
}

-(NSLayoutConstraint *)pinAttribute:(NSLayoutAttribute)attribute toAttribute:(NSLayoutAttribute)toAttribute ofItem:(id)peerItem
{
    return [self pinAttribute:attribute toAttribute:toAttribute ofItem:peerItem withConstant:0];
}

-(NSLayoutConstraint *)pinAttribute:(NSLayoutAttribute)attribute toAttribute:(NSLayoutAttribute)toAttribute ofItem:(id)peerItem withConstant:(CGFloat)constant relation:(NSLayoutRelation)relation
{
    NSParameterAssert(peerItem);
    
    JRTView *superview;
    if ([peerItem isKindOfClass:[JRTView class]])
    {
        superview = [self commonSuperviewWithView:peerItem];
        NSAssert(superview,@"Can't create constraints without a common superview");
    }
    else
    {
        superview = self.superview;
    }
    NSAssert(superview,@"Can't create constraints without a common superview");

    NSLayoutConstraint *constraint = [NSLayoutConstraint constraintWithItem:self attribute:attribute relatedBy:relation toItem:peerItem attribute:toAttribute multiplier:1.0 constant:constant];
    [superview addConstraint:constraint];
    return constraint;
}

-(NSLayoutConstraint *)pinAttribute:(NSLayoutAttribute)attribute toSameAttributeOfItem:(id)peerItem
{
    return [self pinAttribute:attribute toAttribute:attribute ofItem:peerItem withConstant:0];
}

-(NSLayoutConstraint *)pinAttribute:(NSLayoutAttribute)attribute toSameAttributeOfItem:(id)peerItem withConstant:(CGFloat)constant
{
    return [self pinAttribute:attribute toAttribute:attribute ofItem:peerItem withConstant:constant];
}

-(NSArray *)pinEdges:(JRTViewPinEdges)edges toSameEdgesOfView:(JRTView *)peerView
{
    return [self pinEdges:edges toSameEdgesOfView:peerView inset:0];
}

-(NSArray *)pinEdges:(JRTViewPinEdges)edges toSameEdgesOfView:(JRTView *)peerView inset:(CGFloat)inset
{
    JRTView *superview = [self commonSuperviewWithView:peerView];
    NSAssert(superview,@"Can't create constraints without a common superview");
    
    NSMutableArray *constraints = [NSMutableArray arrayWithCapacity:4];
    
    if (edges & JRTViewPinTopEdge)
    {
        [constraints addObject:[self pinAttribute:NSLayoutAttributeTop toAttribute:NSLayoutAttributeTop ofItem:peerView withConstant:inset]];
    }
    if (edges & JRTViewPinLeftEdge)
    {
        [constraints addObject:[self pinAttribute:NSLayoutAttributeLeft toAttribute:NSLayoutAttributeLeft ofItem:peerView withConstant:inset]];
    }
    if (edges & JRTViewPinRightEdge)
    {
        [constraints addObject:[self pinAttribute:NSLayoutAttributeRight toAttribute:NSLayoutAttributeRight ofItem:peerView withConstant:-inset]];
    }
    if (edges & JRTViewPinBottomEdge)
    {
        [constraints addObject:[self pinAttribute:NSLayoutAttributeBottom toAttribute:NSLayoutAttributeBottom ofItem:peerView withConstant:-inset]];
    }
    [superview addConstraints:constraints];
    return [constraints copy];
}

#pragma mark - Pinning to a fixed point

-(NSArray*)pinPointAtX:(NSLayoutAttribute)x Y:(NSLayoutAttribute)y toPoint:(CGPoint)point
{
    JRTView *superview = self.superview;
    NSAssert(superview,@"Can't create constraints without a superview");
    
    // Valid X positions are Left, Center, Right and Not An Attribute
    __unused BOOL xValid = (x == NSLayoutAttributeLeft || x == NSLayoutAttributeCenterX || x == NSLayoutAttributeRight || x == NSLayoutAttributeNotAnAttribute);
    // Valid Y positions are Top, Center, Baseline, Bottom and Not An Attribute
    __unused BOOL yValid = (y == NSLayoutAttributeTop || y == NSLayoutAttributeCenterY || y == NSLayoutAttributeBaseline || y == NSLayoutAttributeBottom || y == NSLayoutAttributeNotAnAttribute);
    
    NSAssert (xValid && yValid,@"Invalid positions for creating constraints");
    
    NSMutableArray *constraints = [NSMutableArray array];
    
    if (x != NSLayoutAttributeNotAnAttribute)
    {
        NSLayoutConstraint *constraint = [NSLayoutConstraint constraintWithItem:self attribute:x relatedBy:NSLayoutRelationEqual toItem:superview attribute:NSLayoutAttributeLeft multiplier:1.0 constant:point.x];
        [constraints addObject:constraint];
    }
    
    if (y != NSLayoutAttributeNotAnAttribute)
    {
        NSLayoutConstraint *constraint = [NSLayoutConstraint constraintWithItem:self attribute:y relatedBy:NSLayoutRelationEqual toItem:superview attribute:NSLayoutAttributeTop multiplier:1.0 constant:point.y];
        [constraints addObject:constraint];
    }
    [superview addConstraints:constraints];
    return [constraints copy];
}

#pragma mark - Spacing Views

-(NSArray*)spaceViews:(NSArray*)views onAxis:(JRTLayoutConstraintAxis)axis withSpacing:(CGFloat)spacing alignmentOptions:(NSLayoutFormatOptions)options
{
    return [self spaceViews:views onAxis:axis withSpacing:spacing alignmentOptions:options flexibleFirstItem:NO];
}

-(NSArray*)spaceViews:(NSArray*)views onAxis:(JRTLayoutConstraintAxis)axis withSpacing:(CGFloat)spacing alignmentOptions:(NSLayoutFormatOptions)options flexibleFirstItem:(BOOL)flexibleFirstItem
{
    return [self spaceViews:views onAxis:axis withSpacing:spacing alignmentOptions:options flexibleFirstItem:flexibleFirstItem applySpacingToEdges:YES];
}

-(NSArray*)spaceViews:(NSArray*)views onAxis:(JRTLayoutConstraintAxis)axis withSpacing:(CGFloat)spacing alignmentOptions:(NSLayoutFormatOptions)options flexibleFirstItem:(BOOL)flexibleFirstItem applySpacingToEdges:(BOOL)spaceEdges
{
    NSAssert([views count] > 1,@"Can only distribute 2 or more views");
    NSString *direction = nil;
    NSLayoutAttribute attribute;
    switch (axis) {
        case JRTLayoutConstraintAxisHorizontal:
            direction = @"H:";
            attribute = NSLayoutAttributeWidth;
            break;
        case JRTLayoutConstraintAxisVertical:
            direction = @"V:";
            attribute = NSLayoutAttributeHeight;
            break;
        default:
            return @[];
    }
    
    JRTView *previousView = nil;
    JRTView *firstView = views[0];
    NSDictionary *metrics = @{@"spacing":@(spacing)};
    NSString *vfl = nil;
    NSMutableArray *constraints = [NSMutableArray array];
    for (JRTView *view in views)
    {
        vfl = nil;
        NSDictionary *views = nil;
        if (previousView)
        {
            if (previousView == firstView && flexibleFirstItem)
            {
                vfl = [NSString stringWithFormat:@"%@[previousView(>=view)]-spacing-[view]",direction];
            }
            else
            {
                vfl = [NSString stringWithFormat:@"%@[previousView(==view)]-spacing-[view]",direction];
            }
            views = NSDictionaryOfVariableBindings(previousView,view);
        }
        else
        {
            vfl = [NSString stringWithFormat:@"%@|%@[view]",direction, spaceEdges ? @"-spacing-" : @""];
            views = NSDictionaryOfVariableBindings(view);
        }
        
        [constraints addObjectsFromArray:[NSLayoutConstraint constraintsWithVisualFormat:vfl options:options metrics:metrics views:views]];
        if (previousView == firstView && flexibleFirstItem)
        {
            [constraints addObject:[NSLayoutConstraint constraintWithItem:firstView attribute:attribute relatedBy:NSLayoutRelationLessThanOrEqual toItem:view attribute:attribute multiplier:1.0 constant:2.0]];
        }
        previousView = view;
    }
    
    vfl = [NSString stringWithFormat:@"%@[previousView]%@|",direction, spaceEdges ? @"-spacing-" : @""];
    [constraints addObjectsFromArray:[NSLayoutConstraint constraintsWithVisualFormat:vfl options:options metrics:metrics views:NSDictionaryOfVariableBindings(previousView)]];
    
    [self addConstraints:constraints];
    return [constraints copy];
}

-(NSArray*)spaceViews:(NSArray *)views onAxis:(JRTLayoutConstraintAxis)axis
{
    NSAssert([views count] > 1,@"Can only distribute 2 or more views");

    NSLayoutAttribute attributeForView;
    NSLayoutAttribute attributeToPin;

    switch (axis) {
        case JRTLayoutConstraintAxisHorizontal:
            attributeForView = NSLayoutAttributeCenterX;
            attributeToPin = NSLayoutAttributeRight;
            break;
        case JRTLayoutConstraintAxisVertical:
            attributeForView = NSLayoutAttributeCenterY;
            attributeToPin = NSLayoutAttributeBottom;
            break;
        default:
            return @[];
    }

    CGFloat fractionPerView = 1.0 / (CGFloat)([views count] + 1);
    
    NSMutableArray *constraints = [NSMutableArray array];
    [views enumerateObjectsUsingBlock:^(JRTView *view, NSUInteger idx, BOOL *stop)
    {
        CGFloat multiplier = fractionPerView * (idx + 1.0);
        [constraints addObject:[NSLayoutConstraint constraintWithItem:view attribute:attributeForView relatedBy:NSLayoutRelationEqual toItem:self attribute:attributeToPin multiplier:multiplier constant:0.0]];
    }];
    
    [self addConstraints:constraints];
    return [constraints copy];
}

#pragma mark - Private

-(JRTView*)commonSuperviewWithView:(JRTView*)peerView
{
    JRTView *commonSuperview = nil;
    JRTView *startView = self;
    do {
#if TARGET_OS_IPHONE
        if ([peerView isDescendantOfView:startView])
#else
        if ([peerView isDescendantOf:startView])
#endif
        {
            commonSuperview = startView;
        }
        startView = startView.superview;
    } while (startView && !commonSuperview);
    
    return commonSuperview;
}

-(NSLayoutConstraint *)applyAttribute:(NSLayoutAttribute)attribute withConstant:(CGFloat)constant relation:(NSLayoutRelation)relation
{
    NSLayoutConstraint *constraint = [NSLayoutConstraint constraintWithItem:self attribute:attribute relatedBy:relation toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1.0 constant:constant];
    [self addConstraint:constraint];
    return constraint;
}

#pragma mark - Deprecated

-(NSLayoutConstraint *)pinAttribute:(NSLayoutAttribute)attribute toSameAttributeOfView:(JRTView *)peerView
{
    return [self pinAttribute:attribute toSameAttributeOfItem:peerView];
}

-(NSLayoutConstraint *)pinEdge:(NSLayoutAttribute)edge toEdge:(NSLayoutAttribute)toEdge ofView:(JRTView*)peerView
{
    return [self pinEdge:edge toEdge:toEdge ofItem:peerView inset:0.0];
}

-(NSLayoutConstraint *)pinEdge:(NSLayoutAttribute)edge toEdge:(NSLayoutAttribute)toEdge ofView:(JRTView *)peerView inset:(CGFloat)inset
{
    return [self pinEdge:edge toEdge:toEdge ofItem:peerView inset:inset];
}

- (NSLayoutConstraint *)pinEdge:(NSLayoutAttribute)edge toEdge:(NSLayoutAttribute)toEdge ofItem:(id)peerItem
{
    return [self pinEdge:edge toEdge:toEdge ofItem:peerItem inset:0.0];
}

- (NSLayoutConstraint *)pinEdge:(NSLayoutAttribute)edge toEdge:(NSLayoutAttribute)toEdge ofItem:(id)peerItem inset:(CGFloat)inset
{
    return [self pinEdge:edge toEdge:toEdge ofItem:peerItem inset:inset relation:NSLayoutRelationEqual];
}

-(NSLayoutConstraint *)pinEdge:(NSLayoutAttribute)edge toEdge:(NSLayoutAttribute)toEdge ofItem:(id)peerItem inset:(CGFloat)inset relation:(NSLayoutRelation)relation
{
    return [self pinAttribute:edge toAttribute:toEdge ofItem:peerItem withConstant:inset relation:relation];
}

@end