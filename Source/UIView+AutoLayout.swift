//
//  UIView+AutoLayout.swift
//  UIView+AutoLayout
//
//  Created by Rob Nadin on 24/10/2014.
//  Copyright (c) 2014 Rob Nadin. All rights reserved.
//

import UIKit

/**
*  Options for pinning item edges.
*/
struct ViewPinEdges: RawOptionSetType, BooleanType {
    private var value: UInt = 0
    typealias RawValue = UInt
    init?(_ value: UInt) { self.value = value }
    init(rawValue value: UInt) { self.value = value }
    init(nilLiteral: ()) { self.value = 0 }
    static var allZeros: ViewPinEdges { return self(0)! }
    var rawValue: UInt { return self.value }
    var boolValue: Bool { return self.rawValue != 0 }
    
    /// Pins the top edge of an item.
    static var TopEdge: ViewPinEdges { return self(1 << 0)! }
    
    /// Pins the right edge of an item.
    static var RightEdge: ViewPinEdges { return self(1 << 1)! }
    
    /// Pins the bottom edge of an item.
    static var BottomEdge: ViewPinEdges { return self(1 << 2)! }
    
    /// Pins the left edge of an item.
    static var LeftEdge: ViewPinEdges { return self(1 << 3)! }
    
    /// Pins all edges of an item.
    static var AllEdges: ViewPinEdges { return self(~0 >> 1)! }
}

/** This AutoLayout category provides convenience methods to make writing AutoLayout code less verbose than directly using the `NSLayoutConstraint` methods.

For more information about these methods check out this blog post: http://commandshift.co.uk/blog/2013/02/20/creating-individual-layout-constraints/
*/
extension UIView {
    
    // MARK: Initializing a View Object
    
    /**
    * @name Initializing a View Object
    */
    
    /**
    *  Returns a frameless view that does not automatically use autoresizing (for use in autolayouts).
    *
    *  @return A frameless view that does not automatically use autoresizing (for use in autolayouts).
    */
    class func autoLayoutView() -> Self {
        let view = self()
        view.setTranslatesAutoresizingMaskIntoConstraints(false)
        return view
    }
    
    // MARK: Pinning to the Superview
    
    /**
    * @name Pinning to the Superview
    */
    
    /**
    *  Pins a view to specific edge(s) of its superview, with a specified inset, using the layout guides of the viewController parameter for top and bottom pinning if appropriate.
    *
    *  @param edges The edges of the superview the receiver should pin to.
    *  @param inset The amount of space that the receiver should inset itself to within the superview.
    *  @param viewController The `UIViewController` with the top and bottom layout guides that should be respected by the method. Setting this value to `nil` will force the constraints to ignore the top and bottom layout guides. If the layout guides do not exist (pre iOS 7) then this method will ignore the layout guides.
    *
    *  @return An array of `NSLayoutConstraint` objects generated by this method.
    */
    func pinToSuperviewEdges(_ edges: ViewPinEdges = .AllEdges, inset: CGFloat = 0, usingLayoutGuidesFrom viewController: UIViewController? = nil) -> [NSLayoutConstraint] {
        assert(superview != nil, "Can't pin to a superview if no superview exists")
        
        var topItem: UILayoutSupport? = viewController?.topLayoutGuide
        var bottomItem: UILayoutSupport? = viewController?.bottomLayoutGuide
        
        var constraints = [NSLayoutConstraint]()

        if edges & .TopEdge {
            let item: AnyObject? = topItem != nil ? topItem : superview
            let attribute: NSLayoutAttribute = topItem != nil ? .Bottom : .Top
            constraints.append(pinAttribute(.Top, toAttribute: attribute, ofItem: item!, withConstant: inset))
        }
        if edges & .LeftEdge {
            constraints.append(pinAttribute(.Left, toAttribute: .Left, ofItem: superview!, withConstant: inset))
        }
        if edges & .RightEdge {
            constraints.append(pinAttribute(.Right, toAttribute: .Right, ofItem: superview!, withConstant: -inset))
        }
        if edges & .BottomEdge {
            let item: AnyObject? = bottomItem != nil ? bottomItem : superview
            let attribute: NSLayoutAttribute = bottomItem != nil ? .Top : .Bottom
            constraints.append(pinAttribute(.Bottom, toAttribute: attribute, ofItem: item!, withConstant: -inset))
        }
        return constraints
    }
    
    /**
    *  Pins a view to all edges of its superview, with specified edge insets
    *
    *  @param insets The amount of space that the receiver should inset itself to within the superview from each edge.
    *
    *  @return An array of `NSLayoutConstraint` objects generated by this method.
    */
    func pinToSuperviewEdgesWithInset(inset: UIEdgeInsets) -> [NSLayoutConstraint] {
        var constraints = [NSLayoutConstraint]()
    
        constraints.extend(pinToSuperviewEdges(.TopEdge, inset: inset.top))
        constraints.extend(pinToSuperviewEdges(.LeftEdge, inset: inset.left))
        constraints.extend(pinToSuperviewEdges(.BottomEdge, inset: inset.bottom))
        constraints.extend(pinToSuperviewEdges(.RightEdge, inset: inset.right))
        
        return constraints
    }
    
    /**
    *  Pins a view's edge to a peer view's edge
    *
    *  @param edges    The edges that should be pinned to the peerView's edges.
    *  @param peerView The view that the receiver is being pinned to.
    *  @param inset    The inset that is applied to the attributes.
    *
    *  @return The `NSLayoutConstraint` generated by this method.
    */
    func pinEdge(edge: NSLayoutAttribute, toEdge: NSLayoutAttribute, ofView peerView: UIView, inset: CGFloat = 0) -> NSLayoutConstraint {
        assert(superview != nil, "Can't create constraints without a superview")
        assert(superview == peerView.superview, "Can't create constraints between views that don't share a superview")
//        assert(edge >= NSLayoutAttribute.Left && edge <= NSLayoutAttribute.Bottom, "Edge parameter is not an edge")
//        assert(toEdge >= NSLayoutAttribute.Left && edge <= NSLayoutAttribute.Bottom, "Edge parameter is not an edge")
        
        var constraint = NSLayoutConstraint(item: self, attribute: edge, relatedBy: .Equal, toItem: peerView, attribute: toEdge, multiplier: 1.0, constant: inset)
        superview?.addConstraintToView(constraint)
        return constraint
    }
    
    // MARK: Centering Views
    
    /**
    * @name Centering Views
    */
    
    /**
    *  Centers the receiver in the specified view.
    *
    *  @param view The view you want to center the receiver in.
    *
    *  @return An array of `NSLayoutConstraint` objects generated by this method.
    */
    func centerInView(view: UIView) -> [NSLayoutConstraint] {
        var constraints = [NSLayoutConstraint]()
    
        constraints.append(centerInView(view, onAxis: .CenterX))
        constraints.append(centerInView(view, onAxis: .CenterY))
    
        return constraints
    }
    
    /**
    *  Centers the receiver in the specified view on a specific axis.
    *
    *  @param view The view you want to center the receiver in.
    *  @param axis The axis of the superview you wish to center the receiver in. This parameter accepts `NSLayoutAttributeCenterX` or `NSLayoutAttributeCenterY`.
    *
    *  @return The `NSLayoutConstraint` generated by this method.
    */
    func centerInView(view: UIView, onAxis axis: NSLayoutAttribute) -> NSLayoutConstraint {
        assert(axis == .CenterX || axis == .CenterY, "Invalid parameter not satisfying: axis")
        return pinAttribute(axis, toSameAttributeOfItem: view)
    }
    
    /**
    *  Centers the receiver in its superview on both the x and y axis.
    *
    *  @return An array of `NSLayoutConstraint` objects generated by this method.
    */
    func centerInContainer() -> [NSLayoutConstraint] {
        return centerInView(superview!)
    }
    
    /**
    *  Centers the receiver in the superview on a specified axis.
    *
    *  @param axis The axis of the superview you wish to center the receiver in. This parameter accepts `NSLayoutAttributeCenterX` or `NSLayoutAttributeCenterY`.
    *
    *  @return The `NSLayoutConstraint` generated by this method.
    */
    func centerInContainerOnAxis(axis: NSLayoutAttribute) -> NSLayoutConstraint {
        return centerInView(superview!, onAxis: axis)
    }
    
    // MARK: Constraining to a fixed size
    
    /**
    * @name Constraining to a fixed size
    */
    
    /**
    *  Constrains the receiver to a fixed size.
    *  @warning Setting an axis to 0.0 will result in no constraint being applied to that axis.
    *
    *  @param size The size to constrain the receiver to.
    *
    *  @return An array of `NSLayoutConstraint` objects generated by this method.
    */
    func constrainToSize(size: CGSize) -> [NSLayoutConstraint] {
        var constraints = [NSLayoutConstraint]()
    
        if size.width > 0 {
            constraints.append(constrainToWidth(size.width))
        }
        if size.height > 0 {
            constraints.append(constrainToHeight(size.height))
        }
    
        return constraints
    }
    
    /**
    *  Constrains the receiver to a fixed width.
    *
    *  @param width The width to constrain the receiver to
    *
    *  @return The `NSLayoutConstraint` generated by this method.
    */
    func constrainToWidth(width: CGFloat) -> NSLayoutConstraint {
        return applyAttribute(.Width, withConstant: width, relation: .Equal)
    }
    
    /**
    *  Constrains the receiver to a fixed height.
    *
    *  @param height The height to constrain the receiver to
    *
    *  @return The `NSLayoutConstraint` generated by this method.
    */
    func constrainToHeight(height: CGFloat) -> NSLayoutConstraint {
        return applyAttribute(.Height, withConstant: height, relation: .Equal)
    }
    
    /**
    *  Applies the minimum and maximum size constrains to the receiver.
    *  @warning Setting an axis to 0.0 will result in no constraint being applied to that axis.
    *
    *  @param minimum The minimum size the receiver should be constrained to
    *  @param maximum The maximum size the receiver should be constrained to
    *
    *  @return An array of `NSLayoutConstraint` objects generated by this method.
    */
    func constrainToMinimumSize(minimum: CGSize, maximumSize maximum: CGSize) {
        assert(minimum.width <= maximum.width, "maximum width should be strictly wider than or equal to minimum width")
        assert(minimum.height <= maximum.height, "maximum height should be strictly higher than or equal to minimum height")
        var minimumConstraints = constrainToMinimumSize(minimum)
        let maximumConstraints = constrainToMaximumSize(maximum)
        return minimumConstraints.extend(maximumConstraints)
    }
    
    /**
    *  Applies the minimum size constrains to the receiver.
    *  @warning Setting an axis to 0.0 will result in no constraint being applied to that axis.
    *
    *  @param minimum The minimum size the receiver should be constrained to
    *
    *  @return An array of `NSLayoutConstraint` objects generated by this method.
    */
    func constrainToMinimumSize(minimum: CGSize) -> [NSLayoutConstraint] {
        var constraints = [NSLayoutConstraint]()
        if minimum.width > 0 {
            constraints.append(applyAttribute(.Width, withConstant: minimum.width, relation: .GreaterThanOrEqual))
        }
        if minimum.height > 0 {
            constraints.append(applyAttribute(.Height, withConstant: minimum.height, relation: .GreaterThanOrEqual))
        }
        return constraints
    }
    
    /**
    *  Applies the maximum size constrains to the receiver.
    *  @warning Setting an axis to 0.0 will result in no constraint being applied to that axis.
    *
    *  @param maximum The maximum size the receiver should be constrained to
    *
    *  @return An array of `NSLayoutConstraint` objects generated by this method.
    */
    func constrainToMaximumSize(maximum: CGSize) -> [NSLayoutConstraint] {
        var constraints = [NSLayoutConstraint]()
        if maximum.width > 0 {
            constraints.append(applyAttribute(.Width, withConstant: maximum.width, relation: .LessThanOrEqual))
        }
        if maximum.height > 0 {
            constraints.append(applyAttribute(.Height, withConstant: maximum.height, relation:.LessThanOrEqual))
        }
        return constraints
    }
    
    // MARK: Pinning to other items
    
    /**
    * @name Pinning to other items
    */
    
    /**
    *  Pins an attribute to any valid attribute of the peer item. The item may be the layout guide of a view controller. Provide a constant for offset/inset along with a relation.
    *
    *  @param attribute     The attribute of the receiver that you want to pin.
    *  @param toAttribute   The attribute of the `peerView` that you want to pin.
    *  @param peerItem      The item that you want to pin the receiver to. (either `UIView` or `UILayoutSupport`).
    *  @param constant      The constant that you want to apply to the constraint.
    *  @param relation      The relation that you wish to apply to the constraint.
    *
    *  @return The `NSLayoutConstraint` generated by this method.
    */
    func pinAttribute(attribute: NSLayoutAttribute, toAttribute: NSLayoutAttribute, ofItem peerItem: AnyObject!, withConstant constant: CGFloat = 0, relation: NSLayoutRelation = NSLayoutRelation.Equal) ->  NSLayoutConstraint {
        assert(peerItem != nil, "Invalid parameter not satisfying: peerItem")
    
        var superview: UIView?
        if peerItem!.isKindOfClass(UIView) {
            superview = commonSuperview(view: peerItem as UIView)
            assert(superview != nil, "Can't create constraints without a common superview")
        } else {
            superview = self.superview
        }
        assert(superview != nil, "Can't create constraints without a common superview")
    
        let constraint = NSLayoutConstraint(item: self, attribute: attribute, relatedBy: relation, toItem: peerItem, attribute: toAttribute, multiplier: 1.0, constant: constant)
        superview?.addConstraintToView(constraint)
        return constraint
    }
    
    /**
    *  Pins an attribute to the same attribute of the peer item. The item may be the layout guide of a view controller. Provide a constant for offset/inset
    *
    *  @param attribute The attribute of the receiver that you want to pin to the `peerView`.
    *  @param peerItem  The view you want to pin the receiver to.
    *  @param constant  The constant to be applied to the constraint.
    *
    *  @return The `NSLayoutConstraint` generated by this method.
    */
    func pinAttribute(attribute: NSLayoutAttribute, toSameAttributeOfItem peerItem: AnyObject!, withConstant constant: CGFloat = 0) -> NSLayoutConstraint {
        return pinAttribute(attribute, toAttribute: attribute, ofItem: peerItem, withConstant: constant)
    }
    
    /**
    *  Pins the receivers edge(s) to another views edge(s). Both views must be in the same view hierarchy.
    *
    *  @param edges    The edges that should be pinned to the peerView's edges.
    *  @param peerView The view that the receiver is being pinned to.
    *  @param inset    The inset that is applied to the attributes.
    *
    *  @return An array of `NSLayoutConstraint` objects generated by this method.
    */
    func pinEdges(edges: ViewPinEdges, toSameEdgesOfView peerView: UIView, inset: CGFloat = 0) -> [NSLayoutConstraint] {
        var superview = commonSuperview(view: peerView)
        assert(superview != nil, "Can't create constraints without a common superview")
    
        var constraints = [NSLayoutConstraint]();
        
        if edges & .TopEdge {
            constraints.append(pinAttribute(.Top, toAttribute: .Top, ofItem: peerView, withConstant: inset))
        }
        if edges & .LeftEdge {
            constraints.append(pinAttribute(.Left, toAttribute: .Left, ofItem: peerView, withConstant: inset))
        }
        if edges & .RightEdge {
            constraints.append(pinAttribute(.Right, toAttribute: .Right, ofItem: peerView, withConstant: -inset))
        }
        if edges & .BottomEdge {
            constraints.append(pinAttribute(.Bottom, toAttribute: .Bottom, ofItem: peerView, withConstant: -inset))
        }
        superview?.addConstraintsToView(constraints)
        return constraints
    }
    
    // MARK: Pinning to a fixed point
    
    /**
    * @name Pinning to a fixed point
    */
    
    /**
    Pins a point to a specific point in the superview's frame. Use NSLayoutAttributeNotAnAttribute to only pin in one dimension.
    
    Acceptable values for x attribute:
    
    - `NSLayoutAttributeLeft`
    - `NSLayoutAttributeCenterX`
    - `NSLayoutAttributeRight`
    - `NSLayoutAttributeNotAnAttribute`
    
    Acceptable values for y attribute:
    
    - `NSLayoutAttributeTop`
    - `NSLayoutAttributeCenterY`
    - `NSLayoutAttributeBaseline`
    - `NSLayoutAttributeBottom`
    - `NSLayoutAttributeNotAnAttribute`
    
    @param x     The x attribute of the receiver that should be pinned.
    @param y     The y attribute of the receiver that should be pinned.
    @param point The point in the superview's frame that the receiver should be pinned to.
    
    @return An array of `NSLayoutConstraint` objects generated by this method.
    */
    func pinPointAtX(x: NSLayoutAttribute, Y y: NSLayoutAttribute, toPoint point: CGPoint) -> [NSLayoutConstraint] {
        assert(superview != nil, "Can't create constraints without a superview")
    
        // Valid X positions are Left, Center, Right and Not An Attribute
        var xValid = (x == .Left || x == .CenterX || x == .Right || x == .NotAnAttribute)
        // Valid Y positions are Top, Center, Baseline, Bottom and Not An Attribute
        var yValid = (y == .Top || y == .CenterY || y == .Baseline || y == .Bottom || y == .NotAnAttribute)
    
        assert(xValid && yValid, "Invalid positions for creating constraints")
    
        var constraints = [NSLayoutConstraint]()
    
        if x != NSLayoutAttribute.NotAnAttribute {
            var constraint = NSLayoutConstraint(item: self, attribute: x, relatedBy: .Equal, toItem: superview, attribute: .Left, multiplier: 1.0, constant: point.x)
            constraints.append(constraint)
        }
    
        if y != NSLayoutAttribute.NotAnAttribute {
            var constraint = NSLayoutConstraint(item: self, attribute: y, relatedBy: .Equal, toItem: superview, attribute: .Top, multiplier: 1.0, constant: point.y)
            constraints.append(constraint)
        }
        superview?.addConstraintsToView(constraints)
        return constraints
    }
    
    // MARK: Spacing Views
    
    /**
    * @name Spacing Views
    */
    
    /**
    *  Spaces the views evenly along the selected axis, with optional flexibility allowed for the first view, in cases where the views do not divide evenly within the container.
    *
    *  @param views   The receivers subviews that should be spaced inside the receiver.
    *  @param axis    The axis that the subviews should be spaced along.
    *  @param spacing The spacing between the subviews being spaced.
    *  @param options The alignment options applied to the constraints.
    *  @param flexibleFirstItem Option to create constraints on the first view such that there is some flexibility on the width
    *  @param spaceEdges Determines if the spacing should be applied to the edges of each item or not. Defaults to `NO` in simplified methods.
    *
    *  @return An array of `NSLayoutConstraint` objects generated by this method.
    */
    func spaceViews(views: [UIView], onAxis axis: UILayoutConstraintAxis, withSpacing spacing: CGFloat, alignmentOptions options: NSLayoutFormatOptions, flexibleFirstItem: Bool = false, applySpacingToEdges spaceEdges: Bool = true) -> [NSLayoutConstraint] {
        assert(views.count > 1, "Can only distribute 2 or more views")
        var direction: String
        var attribute: NSLayoutAttribute
        switch (axis) {
        case .Horizontal:
            direction = "H:"
            attribute = .Width
        case .Vertical:
            direction = "V:"
            attribute = .Height
        default:
            return []
        }
    
        var previousView: UIView?
        var firstView = views[0] as UIView
        var metrics: Dictionary = ["spacing": spacing]
        var vfl: String!
        var constraints = [NSLayoutConstraint]()
        for view: UIView in views as [UIView] {
            vfl = nil
            var views: [NSObject: UIView]
            if previousView != nil {
                if previousView == firstView && flexibleFirstItem {
                    vfl = String(format: "%@[previousView(>=view)]-spacing-[view]", direction)
                } else {
                    vfl = String(format: "%@[previousView(==view)]-spacing-[view]", direction)
                }
                views = ["previousView": previousView!, "view": view]
            } else {
                vfl = String(format: "%@|%@[view]", direction, spaceEdges ? "-spacing-" : "")
                views = ["view": view]
            }
    
            constraints.extend(NSLayoutConstraint.constraintsWithVisualFormat(vfl, options: options, metrics: metrics, views: views) as [NSLayoutConstraint])
            if previousView == firstView && flexibleFirstItem {
                constraints.append(NSLayoutConstraint(item: firstView, attribute: attribute, relatedBy: .LessThanOrEqual, toItem: view, attribute: attribute, multiplier: 1.0, constant: 2.0))
            }
            previousView = view
        }
    
        vfl = String(format: "%@[previousView]%@|", direction, spaceEdges ? "-spacing-" : "")
        constraints.extend(NSLayoutConstraint.constraintsWithVisualFormat(vfl, options: options, metrics: metrics, views: ["previousView": previousView!]) as [NSLayoutConstraint])

        addConstraintsToView(constraints)
        return constraints
    }
    
    /**
    *  Spaces the views evenly along the selected axis, using their intrinsic size
    *
    *  @param views The receivers subviews that should be spaced inside the receiver.
    *  @param axis  The axis that the subviews should be spaced along.
    *
    *  @return An array of `NSLayoutConstraint` objects generated by this method.
    */
    func spaceViews(views: [UIView], onAxis axis: UILayoutConstraintAxis) -> [NSLayoutConstraint] {
        assert(views.count > 1, "Can only distribute 2 or more views")
    
        var attributeForView: NSLayoutAttribute?
        var attributeToPin: NSLayoutAttribute?
    
        switch axis {
        case UILayoutConstraintAxis.Horizontal:
            attributeForView = .CenterX
            attributeToPin = .Right
        case UILayoutConstraintAxis.Vertical:
            attributeForView = .CenterY
            attributeToPin = .Bottom
        default:
            return []
        }
    
        var fractionPerView = 1.0 / CGFloat(views.count + 1)
    
        var constraints = [NSLayoutConstraint]()
        (views as NSArray).enumerateObjectsUsingBlock({ (view, idx, stop) -> Void in
            var multiplier = fractionPerView * CGFloat(idx + 1)
            constraints.append(NSLayoutConstraint(item: view, attribute: attributeForView!, relatedBy: .Equal, toItem: self, attribute: attributeToPin!, multiplier: multiplier, constant: 0.0))
        })
    
        addConstraintsToView(constraints)
        return constraints
    }
    
    // MARK: Private
    
    /**
    *  Searches the view hierarchy to find the common superview between the receiver and the `peerView`.
    *
    *  @param peerView The other view in the view hierarchy where the superview should be located.
    *
    *  @return The common superview between the receiver and the `peerView` or nil if the views are not contained in the same view hierarchy.
    */
    private func commonSuperview(view peerView: UIView) -> UIView? {
        var commonSuperview: UIView?
        var startView: UIView? = self
        do {
            if peerView.isDescendantOfView(startView!) {
                commonSuperview = startView
            }
            startView = startView?.superview
        } while (startView != nil && commonSuperview == nil)
        
        return commonSuperview
    }
    
    /**
    *  Applys an attribute to the receiver with a specific constant and relation.
    *
    *  @param attribute The attribute of the receiver that you want to pin.
    *  @param constant  The constant that you want to apply to the constraint.
    *  @param relation  The relation that you wish to apply to the constraint.
    *
    *  @return The `NSLayoutConstraint` generated by this method.
    */
    private func applyAttribute(attribute: NSLayoutAttribute, withConstant constant: CGFloat, relation: NSLayoutRelation) -> NSLayoutConstraint {
        let constraint = NSLayoutConstraint(item: self, attribute: attribute, relatedBy: relation, toItem: nil, attribute: .NotAnAttribute, multiplier: 1.0, constant: constant)
        addConstraintToView(constraint)
        return constraint
    }
    
    private func addConstraintToView(constraint: NSLayoutConstraint) {
        if respondsToSelector(Selector("addConstraint:")) {
            addConstraint(constraint)
        } else {
            constraint.active = true
        }
    }
    
    private func addConstraintsToView(constraints: [AnyObject]) {
        if respondsToSelector(Selector("addConstraints:")) {
            addConstraints(constraints)
        } else {
            NSLayoutConstraint.activateConstraints(constraints)
        }
    }
    
}
